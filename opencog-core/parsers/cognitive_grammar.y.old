%{
/* Cognitive Grammar Parser for OpenCog */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Forward declarations for types we'll use */
typedef struct atom_handle atom_handle_t;
typedef struct {
    double strength;
    double confidence;
} truth_value_t;
typedef struct {
    short sti;
    short lti;
    short vlti;
} attention_value_t;

extern int yylex();
extern void yyerror(const char* s);
extern int yylineno;

/* Global atomspace for parser - will be set by initialization */
void* parser_atomspace = NULL;

%}

%union {
    char* string;
    double number;
    atom_handle_t* atom;
    struct {
        atom_handle_t** atoms;
        size_t count;
    } atom_list;
    truth_value_t tv;
    attention_value_t av;
}

/* Token declarations */
%token CONCEPT PREDICATE LINK NODE EVAL EXEC VARIABLE
%token TRUTH ATTENTION SCHEMA RULE PATTERN BIND
%token AND OR NOT IMPLIES EQUIVALENT FORALL EXISTS
%token CONSTRUCTION FRAME SEMANTIC SYNTACTIC ROLE FILLER CONSTRAINT
%token STRENGTH CONFIDENCE STI LTI VLTI
%token LPAREN RPAREN LBRACE RBRACE LBRACKET RBRACKET
%token COLON SEMICOLON COMMA EQUALS ARROW DOUBLE_ARROW

%token <string> IDENTIFIER STRING
%token <number> NUMBER

/* Type declarations */
%type <atom> atom concept predicate link node expression
%type <atom> variable evaluation execution construction
%type <atom_list> atom_list outgoing_set
%type <tv> truth_value
%type <av> attention_value

/* Operator precedence (lowest to highest) */
%right IMPLIES EQUIVALENT
%left OR
%left AND
%left NOT

/* Start symbol */
%start program

%%

program:
    /* Empty program */
    | program statement SEMICOLON
    ;

statement:
    atom                    { /* Atom definition */ }
    | construction          { /* Cognitive construction */ }
    | rule                  { /* Inference rule */ }
    | schema                { /* Procedure schema */ }
    ;

/* Atom definitions */
atom:
    concept
    | predicate
    | link
    | node
    | variable
    | evaluation
    | execution
    ;

concept:
    CONCEPT IDENTIFIER {
        /* Create concept - stub for now */
        $$ = NULL;
        free($2);
    }
    | CONCEPT IDENTIFIER truth_value {
        /* Create concept with TV - stub for now */
        $$ = NULL;
        free($2);
    }
    ;

predicate:
    PREDICATE IDENTIFIER {
        $$ = atom_create(parser_atomspace, ATOM_TYPE_PREDICATE, $2);
        free($2);
    }
    | PREDICATE IDENTIFIER truth_value {
        $$ = atom_create(parser_atomspace, ATOM_TYPE_PREDICATE, $2);
        atom_set_tv($$, $3.strength, $3.confidence);
        free($2);
    }
    ;

node:
    NODE IDENTIFIER {
        $$ = atom_create(parser_atomspace, ATOM_TYPE_NODE, $2);
        free($2);
    }
    ;

variable:
    VARIABLE IDENTIFIER {
        $$ = atom_create(parser_atomspace, ATOM_TYPE_VARIABLE, $2);
        free($2);
    }
    ;

link:
    LINK IDENTIFIER outgoing_set {
        $$ = atom_create_link(parser_atomspace, ATOM_TYPE_LINK, $3.atoms, $3.count);
        free($2);
        free($3.atoms);
    }
    ;

evaluation:
    EVAL predicate atom_list {
        size_t total = $3.count + 1;
        atom_handle_t** outgoing = malloc(sizeof(atom_handle_t*) * total);
        outgoing[0] = $2;
        for (size_t i = 0; i < $3.count; i++) {
            outgoing[i + 1] = $3.atoms[i];
        }
        $$ = atom_create_link(parser_atomspace, ATOM_TYPE_EVALUATION, outgoing, total);
        free(outgoing);
        free($3.atoms);
    }
    ;

execution:
    EXEC IDENTIFIER atom_list {
        atom_handle_t* schema = atom_create(parser_atomspace, ATOM_TYPE_NODE, $2);
        size_t total = $3.count + 1;
        atom_handle_t** outgoing = malloc(sizeof(atom_handle_t*) * total);
        outgoing[0] = schema;
        for (size_t i = 0; i < $3.count; i++) {
            outgoing[i + 1] = $3.atoms[i];
        }
        $$ = atom_create_link(parser_atomspace, ATOM_TYPE_EXECUTION, outgoing, total);
        free($2);
        free(outgoing);
        free($3.atoms);
    }
    ;

/* Cognitive construction grammar */
construction:
    CONSTRUCTION IDENTIFIER LBRACE construction_body RBRACE {
        /* Create construction frame */
        $$ = atom_create(parser_atomspace, ATOM_TYPE_CUSTOM, $2);
        free($2);
    }
    ;

construction_body:
    /* Empty */
    | construction_body construction_element
    ;

construction_element:
    SEMANTIC COLON semantic_spec SEMICOLON
    | SYNTACTIC COLON syntactic_spec SEMICOLON
    | ROLE IDENTIFIER COLON expression SEMICOLON
    | CONSTRAINT expression SEMICOLON
    ;

semantic_spec:
    expression
    | FRAME IDENTIFIER
    ;

syntactic_spec:
    expression
    ;

/* Rule definitions */
rule:
    RULE IDENTIFIER COLON expression ARROW expression {
        /* Create implication link for rule */
    }
    ;

schema:
    SCHEMA IDENTIFIER LPAREN param_list RPAREN LBRACE schema_body RBRACE {
        /* Create schema definition */
    }
    ;

param_list:
    /* Empty */
    | IDENTIFIER
    | param_list COMMA IDENTIFIER
    ;

schema_body:
    /* Empty */
    | schema_body expression SEMICOLON
    ;

/* Expressions */
expression:
    atom
    | expression AND expression {
        atom_handle_t* outgoing[2] = { $1, $3 };
        $$ = atom_create_link(parser_atomspace, ATOM_TYPE_LINK, outgoing, 2);
    }
    | expression OR expression {
        atom_handle_t* outgoing[2] = { $1, $3 };
        $$ = atom_create_link(parser_atomspace, ATOM_TYPE_LINK, outgoing, 2);
    }
    | NOT expression {
        atom_handle_t* outgoing[1] = { $2 };
        $$ = atom_create_link(parser_atomspace, ATOM_TYPE_LINK, outgoing, 1);
    }
    | expression IMPLIES expression {
        atom_handle_t* outgoing[2] = { $1, $3 };
        $$ = atom_create_link(parser_atomspace, ATOM_TYPE_LINK, outgoing, 2);
    }
    | LPAREN expression RPAREN {
        $$ = $2;
    }
    ;

/* Atom lists */
atom_list:
    atom {
        $$.atoms = malloc(sizeof(atom_handle_t*));
        $$.atoms[0] = $1;
        $$.count = 1;
    }
    | atom_list atom {
        $$.count = $1.count + 1;
        $$.atoms = realloc($1.atoms, sizeof(atom_handle_t*) * $$.count);
        $$.atoms[$$.count - 1] = $2;
    }
    ;

outgoing_set:
    LPAREN atom_list RPAREN {
        $$ = $2;
    }
    | LPAREN RPAREN {
        $$.atoms = NULL;
        $$.count = 0;
    }
    ;

/* Truth values */
truth_value:
    LBRACKET TRUTH COLON NUMBER COMMA NUMBER RBRACKET {
        $$.strength = $4;
        $$.confidence = $6;
    }
    | LBRACKET NUMBER COMMA NUMBER RBRACKET {
        $$.strength = $2;
        $$.confidence = $4;
    }
    ;

/* Attention values */
attention_value:
    LBRACKET ATTENTION COLON NUMBER COMMA NUMBER COMMA NUMBER RBRACKET {
        $$.sti = (int16_t)$4;
        $$.lti = (int16_t)$6;
        $$.vlti = (int16_t)$8;
    }
    ;

%%

/* Parser initialization */
void parser_init(void* space) {
    parser_atomspace = space;
}

/* Main parse function */
int parse_cognitive_grammar(const char* input, void* space) {
    parser_init(space);
    /* Set input buffer and parse */
    /* Return 0 on success, non-zero on error */
    (void)input; /* Suppress unused parameter warning */
    return 0;
}
